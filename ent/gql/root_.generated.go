// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Milestone() MilestoneResolver
	MinterContract() MinterContractResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Launchpad struct {
		ID                  func(childComplexity int) int
		IsCanceled          func(childComplexity int) int
		IsReady             func(childComplexity int) int
		IsSoldOut           func(childComplexity int) int
		MinterContract      func(childComplexity int) int
		Project             func(childComplexity int) int
		PublicSaleOpen      func(childComplexity int) int
		WhitelistedSaleOpen func(childComplexity int) int
	}

	Metadata struct {
		Milestones func(childComplexity int) int
		Rating     func(childComplexity int) int
		TonPrice   func(childComplexity int) int
	}

	Milestone struct {
		Boost func(childComplexity int) int
		Ceil  func(childComplexity int) int
		Ha    func(childComplexity int) int
		Id    func(childComplexity int) int
		Ton   func(childComplexity int) int
	}

	Mint struct {
		ID            func(childComplexity int) int
		MaxValuePerTx func(childComplexity int) int
		MinValuePerTx func(childComplexity int) int
		MinterAddress func(childComplexity int) int
		Project       func(childComplexity int) int
	}

	MinterContract struct {
		Abi     func(childComplexity int) int
		Address func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PaymentToken struct {
		Address func(childComplexity int) int
		Symbol  func(childComplexity int) int
	}

	Project struct {
		Address       func(childComplexity int) int
		ForecastedApr func(childComplexity int) int
		ID            func(childComplexity int) int
		Launchpad     func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Mint          func(childComplexity int) int
		Name          func(childComplexity int) int
		PaymentToken  func(childComplexity int) int
		Slot          func(childComplexity int) int
		Slug          func(childComplexity int) int
		TotalValue    func(childComplexity int) int
		ValueDecimal  func(childComplexity int) int
	}

	ProjectDetails struct {
		Launchpad func(childComplexity int) int
		Mint      func(childComplexity int) int
		Project   func(childComplexity int) int
	}

	Query struct {
		Details func(childComplexity int, slug string) int
		List    func(childComplexity int) int
		Node    func(childComplexity int, id string) int
		Nodes   func(childComplexity int, ids []string) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Launchpad.id":
		if e.complexity.Launchpad.ID == nil {
			break
		}

		return e.complexity.Launchpad.ID(childComplexity), true

	case "Launchpad.is_canceled":
		if e.complexity.Launchpad.IsCanceled == nil {
			break
		}

		return e.complexity.Launchpad.IsCanceled(childComplexity), true

	case "Launchpad.is_ready":
		if e.complexity.Launchpad.IsReady == nil {
			break
		}

		return e.complexity.Launchpad.IsReady(childComplexity), true

	case "Launchpad.is_sold_out":
		if e.complexity.Launchpad.IsSoldOut == nil {
			break
		}

		return e.complexity.Launchpad.IsSoldOut(childComplexity), true

	case "Launchpad.minter_contract":
		if e.complexity.Launchpad.MinterContract == nil {
			break
		}

		return e.complexity.Launchpad.MinterContract(childComplexity), true

	case "Launchpad.project":
		if e.complexity.Launchpad.Project == nil {
			break
		}

		return e.complexity.Launchpad.Project(childComplexity), true

	case "Launchpad.public_sale_open":
		if e.complexity.Launchpad.PublicSaleOpen == nil {
			break
		}

		return e.complexity.Launchpad.PublicSaleOpen(childComplexity), true

	case "Launchpad.whitelisted_sale_open":
		if e.complexity.Launchpad.WhitelistedSaleOpen == nil {
			break
		}

		return e.complexity.Launchpad.WhitelistedSaleOpen(childComplexity), true

	case "Metadata.milestones":
		if e.complexity.Metadata.Milestones == nil {
			break
		}

		return e.complexity.Metadata.Milestones(childComplexity), true

	case "Metadata.rating":
		if e.complexity.Metadata.Rating == nil {
			break
		}

		return e.complexity.Metadata.Rating(childComplexity), true

	case "Metadata.ton_price":
		if e.complexity.Metadata.TonPrice == nil {
			break
		}

		return e.complexity.Metadata.TonPrice(childComplexity), true

	case "Milestone.boost":
		if e.complexity.Milestone.Boost == nil {
			break
		}

		return e.complexity.Milestone.Boost(childComplexity), true

	case "Milestone.ceil":
		if e.complexity.Milestone.Ceil == nil {
			break
		}

		return e.complexity.Milestone.Ceil(childComplexity), true

	case "Milestone.ha":
		if e.complexity.Milestone.Ha == nil {
			break
		}

		return e.complexity.Milestone.Ha(childComplexity), true

	case "Milestone.id":
		if e.complexity.Milestone.Id == nil {
			break
		}

		return e.complexity.Milestone.Id(childComplexity), true

	case "Milestone.ton":
		if e.complexity.Milestone.Ton == nil {
			break
		}

		return e.complexity.Milestone.Ton(childComplexity), true

	case "Mint.id":
		if e.complexity.Mint.ID == nil {
			break
		}

		return e.complexity.Mint.ID(childComplexity), true

	case "Mint.max_value_per_tx":
		if e.complexity.Mint.MaxValuePerTx == nil {
			break
		}

		return e.complexity.Mint.MaxValuePerTx(childComplexity), true

	case "Mint.min_value_per_tx":
		if e.complexity.Mint.MinValuePerTx == nil {
			break
		}

		return e.complexity.Mint.MinValuePerTx(childComplexity), true

	case "Mint.minter_address":
		if e.complexity.Mint.MinterAddress == nil {
			break
		}

		return e.complexity.Mint.MinterAddress(childComplexity), true

	case "Mint.project":
		if e.complexity.Mint.Project == nil {
			break
		}

		return e.complexity.Mint.Project(childComplexity), true

	case "MinterContract.abi":
		if e.complexity.MinterContract.Abi == nil {
			break
		}

		return e.complexity.MinterContract.Abi(childComplexity), true

	case "MinterContract.address":
		if e.complexity.MinterContract.Address == nil {
			break
		}

		return e.complexity.MinterContract.Address(childComplexity), true

	case "PageInfo.end_cursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.has_next_page":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.has_previous_page":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.start_cursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PaymentToken.address":
		if e.complexity.PaymentToken.Address == nil {
			break
		}

		return e.complexity.PaymentToken.Address(childComplexity), true

	case "PaymentToken.symbol":
		if e.complexity.PaymentToken.Symbol == nil {
			break
		}

		return e.complexity.PaymentToken.Symbol(childComplexity), true

	case "Project.address":
		if e.complexity.Project.Address == nil {
			break
		}

		return e.complexity.Project.Address(childComplexity), true

	case "Project.forecasted_apr":
		if e.complexity.Project.ForecastedApr == nil {
			break
		}

		return e.complexity.Project.ForecastedApr(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.launchpad":
		if e.complexity.Project.Launchpad == nil {
			break
		}

		return e.complexity.Project.Launchpad(childComplexity), true

	case "Project.metadata":
		if e.complexity.Project.Metadata == nil {
			break
		}

		return e.complexity.Project.Metadata(childComplexity), true

	case "Project.mint":
		if e.complexity.Project.Mint == nil {
			break
		}

		return e.complexity.Project.Mint(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.payment_token":
		if e.complexity.Project.PaymentToken == nil {
			break
		}

		return e.complexity.Project.PaymentToken(childComplexity), true

	case "Project.slot":
		if e.complexity.Project.Slot == nil {
			break
		}

		return e.complexity.Project.Slot(childComplexity), true

	case "Project.slug":
		if e.complexity.Project.Slug == nil {
			break
		}

		return e.complexity.Project.Slug(childComplexity), true

	case "Project.total_value":
		if e.complexity.Project.TotalValue == nil {
			break
		}

		return e.complexity.Project.TotalValue(childComplexity), true

	case "Project.value_decimal":
		if e.complexity.Project.ValueDecimal == nil {
			break
		}

		return e.complexity.Project.ValueDecimal(childComplexity), true

	case "ProjectDetails.launchpad":
		if e.complexity.ProjectDetails.Launchpad == nil {
			break
		}

		return e.complexity.ProjectDetails.Launchpad(childComplexity), true

	case "ProjectDetails.mint":
		if e.complexity.ProjectDetails.Mint == nil {
			break
		}

		return e.complexity.ProjectDetails.Mint(childComplexity), true

	case "ProjectDetails.project":
		if e.complexity.ProjectDetails.Project == nil {
			break
		}

		return e.complexity.ProjectDetails.Project(childComplexity), true

	case "Query.details":
		if e.complexity.Query.Details == nil {
			break
		}

		args, err := ec.field_Query_details_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Details(childComplexity, args["slug"].(string)), true

	case "Query.list":
		if e.complexity.Query.List == nil {
			break
		}

		return e.complexity.Query.List(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Launchpad implements Node {
  id: ID!
  is_ready: Boolean!
  minter_contract: MinterContract!
  whitelisted_sale_open: Boolean!
  public_sale_open: Boolean!
  is_sold_out: Boolean!
  is_canceled: Boolean!
  project: Project!
}
type Mint implements Node {
  id: ID!
  min_value_per_tx: String!
  max_value_per_tx: String!
  minter_address: String!
  project: Project!
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/carbonable/carbonable-launchpad-backend/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  has_next_page: Boolean!
  """
  When paginating backwards, are there more items?
  """
  has_previous_page: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  start_cursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  end_cursor: Cursor
}
type Project implements Node {
  id: ID!
  address: String!
  slot: Int!
  name: String!
  slug: String!
  value_decimal: Int!
  forecasted_apr: String
  total_value: String!
  payment_token: PaymentToken!
  metadata: Metadata!
  mint: Mint
  launchpad: Launchpad
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
}
`, BuiltIn: false},
	{Name: "../launchpad.graphql", Input: `type MinterContract {
  address: String!
  abi: String!
}
`, BuiltIn: false},
	{Name: "../project.graphql", Input: `type PaymentToken {
  symbol: String!
  address: String!
}
type Milestone {
  id: ID!
  boost: String!
  ha: String!
  ton: String!
  ceil: Int!
}
type Metadata {
  rating: String!
  ton_price: String!
  milestones: [Milestone!]!
}

"""Aggregated project data."""
type ProjectDetails {
  project: Project!
  mint: Mint!
  launchpad: Launchpad!
}

extend type Query {
   """Returns the list of projects available in launchpad."""
   list: [ProjectDetails]!
   """Get project launchpad details filtered by slug."""
   details(slug: String!): ProjectDetails!
}

`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
